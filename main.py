from fastapi import FastAPI, Request, Response, Cookie, HTTPException, Depends
"""
This module defines a FastAPI application for a Dungeons and Dragons game character generator.
It includes various endpoints to generate and retrieve character attributes and context.
Endpoints:
- /store-output/{endpoint_name}: Stores output data for a given endpoint in Redis.
- /get-output/{endpoint_name}/: Retrieves output data for a given endpoint from Redis.
- /race: Generates or retrieves the character's race.
- /class: Generates or retrieves the character's class.
- /background: Generates or retrieves the character's background.
- /class_context: Generates or retrieves the context for the character's class.
- /race_context: Generates or retrieves the context for the character's race.
- /background_context: Generates or retrieves the context for the character's background.
- /abilities: Generates or retrieves the character's abilities.
- /ability_scores: Generates or retrieves the character's ability scores.
- /assign_ability_modifier: Generates or retrieves the character's ability modifiers.
- /proficieny_modifier: Generates or retrieves the character's proficiency modifier.
- /saving_throws: Generates or retrieves the character's saving throws.
- /skills: Generates or retrieves the character's skills.
- /passive_perception: Generates or retrieves the character's passive perception.
- /proficiencies_languages: Generates or retrieves the character's proficiencies and languages.
- /equipment_money: Generates or retrieves the character's equipment and money.
- /attacks: Generates or retrieves the character's attacks.
- /armor: Generates or retrieves the character's armor class.
- /initative: Generates or retrieves the character's initiative.
- /speed: Generates or retrieves the character's speed.
- /hit_dice: Generates or retrieves the character's hit dice.
- /point_maximum: Generates or retrieves the character's hit point maximum.
- /current_hit_point: Generates or retrieves the character's current hit points.
- /features: Generates or retrieves the character's features.
- /traits: Generates or retrieves the character's traits.
- /character_name: Generates or retrieves the character's name.
- /alignment: Generates or retrieves the character's alignment.
- /all: Generates or retrieves all character attributes and context.
Middleware:
- delete_redis_on_swagger_refresh: Clears Redis database when accessing Swagger UI or OpenAPI schema.
Dependencies:
- FastAPI: Web framework for building APIs.
- pydantic: Data validation and settings management using Python type annotations.
- redis: Redis client for Python.
- uuid: UUID generation for unique identifiers.
- inspect: Provides introspection capabilities.
- logger: Custom logging module.
- inference_pipeline: Module containing methods for generating character attributes and context.
"""
from pydantic import BaseModel
from typing import Optional
from inference_pipeline import inference_methods
import redis
import json
import uuid
from logger import log_success, log_failure
from inference_pipeline import dep
from databases.database_conn import connections
from datetime import datetime

app = FastAPI()

conn = connections()

redis_client = conn.connect_redis()
mongo_client = conn.connect_mongo()

inf = inference_methods.dndCharacter(mongo_client)

SESSION_TIMEOUT = 3600  # 1 hour in seconds

db = mongo_client["context_data"]
collection = db["audit_logs"]

@app.middleware("http")
async def delete_redis_on_swagger_refresh(request: Request, call_next):
    """
    Middleware to delete Redis database on Swagger refresh.

    This middleware function intercepts HTTP requests and checks if the request URL path
    is one of the Swagger-related endpoints ("/docs", "/redoc", "/openapi.json"). If it is,
    the Redis database is flushed (all data is deleted). The request is then passed to the
    next middleware or route handler.

    Args:
        request (Request): The incoming HTTP request.
        call_next (Callable): The next middleware or route handler to be called.

    Returns:
        Response: The HTTP response generated by the next middleware or route handler.
    """
    if request.url.path in ["/docs", "/redoc", "/openapi.json"]:
        redis_client.flushdb()  
    response = await call_next(request)
    return response

def get_session_id(request: Request) -> str:
    """Extracts the session ID from headers or generates a new one."""
    return request.headers.get("X-Session-ID", str(uuid.uuid4()))

@app.post('/store-output/{endpoint_name}')
def store_output(endpoint_name: str, data: dict, session_id: str):
    """
    Stores the output data for a given endpoint in a Redis database.

    Args:
        endpoint_name (str): The name of the endpoint for which the data is being stored.
        data (dict): The data to be stored.
        session_id (str, optional): The session ID from the cookie. Defaults to None.

    Raises:
        HTTPException: If the session ID is missing.

    Returns:
        dict: A message indicating that the data has been stored for the specified endpoint.
    """
    if not session_id:
        raise HTTPException(status_code=400, detail="Session ID missing")
    redis_key = f"{session_id}:{endpoint_name}"
    redis_client.setex(redis_key, SESSION_TIMEOUT, json.dumps(data))
    collection.insert_one({
        "session_id": session_id,
        "endpoint_name": endpoint_name,
        "data": data,
        "timestamp": datetime.utcnow().isoformat()
    })
    return {"message": f"Data stored for endpoint '{endpoint_name}'"}

@app.get("/get-output/{endpoint_name}/")
def get_output(endpoint_name: str, session_id: str):
    """
    Retrieve the output data for a given endpoint and session ID from Redis.

    Args:
        endpoint_name (str): The name of the endpoint to retrieve data for.
        session_id (str, optional): The session ID to use for retrieving data. Defaults to None.

    Raises:
        HTTPException: If the session ID is missing.

    Returns:
        dict: A dictionary containing the endpoint name and the retrieved data.
    """
    if not session_id:
        raise HTTPException(status_code=400, detail="Session ID missing")
    redis_key = f"{session_id}:{endpoint_name}"
    data = redis_client.get(redis_key)
    if data:
        return {"endpoint": endpoint_name, "data": json.loads(data)}


@app.get("/race")
async def get_race(session_id: str = Depends(get_session_id)):
    """
    Retrieves the race name for a character. If the race name is not already stored, 
    it fetches the race name using the inf.get_race() function and stores it for future use.

    Returns:
        str: The race name of the character.
    """
    race_name = inf.get_race()
    store_output("get_race", race_name, session_id)

@app.get("/class")
async def get_class(session_id: str = Depends(get_session_id)):
    """
    Retrieves the class name for a character in the game. If the class name has 
    not been previously stored, it fetches the class name using the inf.get_class() 
    function and stores it. If the class name is already stored, it retrieves it 
    from the stored output.

    Returns:
        str: The class name of the character.
    """
    class_name = inf.get_class()
    store_output("get_class", class_name, session_id)

@app.get("/background")
async def get_background(session_id: str = Depends(get_session_id)):
    """
    Retrieves the background name for the game. If the background name is not already stored,
    it fetches the background name using the `inf.get_background()` function and stores it.
    Returns the stored background name.

    Returns:
        str: The background name.
    """
    background_name = inf.get_background()
    store_output("get_background", background_name, session_id)

@app.get("/class_context")
async def get_class_context(session_id: str = Depends(get_session_id)):
    """
    Retrieves the context for a class in the game.

    This function checks if the class context is already stored. If not, it fetches the class context
    based on the class name and stores it for future use. If the class is not assigned, it raises an HTTPException.

    Returns:
        dict: The context of the class.

    Raises:
        HTTPException: If the class is not assigned.
    """
    if not get_output("get_class", session_id):
        raise HTTPException(status_code=400, detail="Class not assigned")
    class_name = get_output("get_class", session_id)['data']
    class_context = inf.get_class_context(class_name)
    store_output("get_class_context", class_context, session_id)

@app.get("/race_context")
async def get_race_context(session_id: str = Depends(get_session_id)):
    """
    Retrieves the context for a race in the game.

    This function first checks if the race has been assigned by calling `get_output("get_race")`.
    If the race is not assigned, it raises an HTTPException with a 400 status code.
    If the race is assigned, it retrieves the race name from the output.

    Then, it checks if the race context is already stored by calling `get_output("get_race_context")`.
    If the race context is not stored, it fetches the race context using `inf.get_race_context(race_name)`
    and stores it using `store_output("get_race_context", race_context)`.

    Finally, it retrieves and returns the stored race context.

    Returns:
        dict: The context of the race.

    Raises:
        HTTPException: If the race is not assigned.
    """
    if not get_output("get_race", session_id):
        raise HTTPException(status_code=400, detail="Race not assigned")
    race_name = get_output("get_race", session_id)['data']
    race_context = inf.get_race_context(race_name)
    store_output("get_race_context", race_context, session_id)

@app.get("/background_context")
async def get_background_context(session_id: str = Depends(get_session_id)):
    """
    Retrieves the background context for a given background.

    This function checks if the background has been assigned and raises an HTTPException if not.
    It then retrieves the background name and checks if the background context is already stored.
    If not, it fetches the background context using the background name and stores it.
    Finally, it returns the stored background context.

    Raises:
        HTTPException: If the background is not assigned.

    Returns:
        dict: The background context.
    """
    if not get_output("get_background", session_id):
        raise HTTPException(status_code=400, detail="Background not assigned")
    background_name = get_output("get_background", session_id)['data']
    background_context = inf.get_background_context(background_name)
    store_output("get_background_context", background_context, session_id)

@app.get("/abilities")
async def get_abilities(session_id: str = Depends(get_session_id)):
    """
    Retrieves the abilities for a given class and class context.

    This function first checks if the class and class context have been assigned.
    If not, it raises an HTTPException with a 400 status code. If the abilities
    have not been previously retrieved, it fetches them using the `inf.get_abilities`
    function and stores the result. Finally, it returns the stored abilities.

    Raises:
        HTTPException: If the class and class context are not assigned.

    Returns:
        dict: The abilities for the specified class and class context.
    """
    if not get_output("get_class", session_id) and get_output("get_class_context", session_id):
        raise HTTPException(status_code=400, detail="Class and Class Context not assigned")
    class_name = get_output("get_class", session_id)['data']
    class_context = get_output("get_class_context", session_id)['data']
    class_abilities = inf.get_abilities(class_name, class_context)
    store_output("get_abilities", class_abilities, session_id)


@app.get("/ability_scores")
async def get_ability_scores(session_id: str = Depends(get_session_id)):
    """
    Retrieve or generate ability scores for a character.

    This function first checks if the abilities have been assigned by calling
    the `get_output` function with the argument "get_abilities". If the abilities
    are not assigned, it raises an HTTPException with a 400 status code.

    If the abilities are assigned, it then checks if the ability scores have
    already been generated by calling the `get_output` function with the argument
    "get_ability_scores". If the ability scores are not generated, it assigns
    scores to the abilities using the `inf.assign_scores` function and stores
    the result using the `store_output` function.

    Finally, it retrieves the ability scores and returns them.

    Returns:
        dict: A dictionary containing the ability scores.

    Raises:
        HTTPException: If the abilities are not assigned.
    """
    if not get_output("get_abilities", session_id):
        raise HTTPException(status_code=400, detail="Abilities not assigned")
    output_abilities = get_output("get_abilities", session_id)
    ability_scores = inf.assign_scores(output_abilities['data'])
    store_output("get_ability_scores", ability_scores, session_id)

@app.get("/assign_ability_modifier")
async def get_ability_modifier(session_id: str = Depends(get_session_id)):
    """
    Retrieves the ability modifier for a character based on their ability scores.

    This function first checks if the ability scores have been assigned. If not, it raises an HTTPException.
    It then calculates the ability modifier if it has not been previously stored and stores it.
    Finally, it retrieves and returns the stored ability modifier.

    Returns:
        dict: The ability modifier for the character.

    Raises:
        HTTPException: If the ability scores have not been assigned.
    """
    if not get_output("get_ability_scores", session_id):
        raise HTTPException(status_code=400, detail="Ability scores not assigned")
    output_ability_scores = get_output("get_ability_scores", session_id)['data']
    ability_modifier = inf.ability_modifier(output_ability_scores)
    store_output("get_ability_modifier", ability_modifier, session_id)

@app.get("/proficieny_modifier")
async def get_proficiency_modifier(session_id: str = Depends(get_session_id)):
    """
    Retrieves the proficiency modifier for a character.

    This function checks if the proficiency modifier has already been calculated
    and stored. If not, it calculates the proficiency modifier using the 
    `inf.proficiency_modifier()` function and stores the result. It then retrieves
    and returns the stored proficiency modifier.

    Returns:
        int: The proficiency modifier for the character.
    """
    proficiency_modifier = inf.proficiency_modifier()
    store_output("get_proficiency_modifier", proficiency_modifier, session_id)

@app.get("/saving_throws")
async def get_saving_throws(session_id: str = Depends(get_session_id)):
    """
    Calculate and retrieve the saving throws for a character based on their class, class context, 
    ability scores, and proficiency modifier.

    Raises:
        HTTPException: If class, class context, ability scores, or proficiency modifier are not assigned.

    Returns:
        dict: The saving throws for the character.
    """
    if not get_output("get_class", session_id) and get_output("get_class_context", session_id):
        raise HTTPException(status_code=400, detail="Class and Class Context not assigned")
    class_name = get_output("get_class", session_id)['data']
    class_context = get_output("get_class_context", session_id)['data']
    if not get_output("get_ability_scores", session_id):
        raise HTTPException(status_code=400, detail="Ability scores not assigned")
    ability_scores = get_output("get_ability_scores", session_id)['data']
    if not get_output("get_proficiency_modifier", session_id):
        raise HTTPException(status_code=400, detail="Proficiency modifier not assigned")
    proficiency_modifier = get_output("get_proficiency_modifier", session_id)['data']['proficiency_modifier']
    saving_throws = inf.saving_throws(class_name, class_context, ability_scores, proficiency_modifier)
    store_output("get_saving_throws", saving_throws, session_id)

@app.get("/skills")
async def get_skills(session_id: str = Depends(get_session_id)):
    """
    Retrieves and stores the skills for a character based on class, background, 
    ability scores, and proficiency modifier. If the skills are already stored, 
    it returns the stored skills.

    Raises:
        HTTPException: If class, class context, background, background context, 
                       ability scores, or proficiency modifier are not assigned.

    Returns:
        dict: The skills of the character.
    """
    if not get_output("get_class", session_id) and get_output("get_class_context", session_id):
        raise HTTPException(status_code=400, detail="Class and Class Context not assigned")
    class_name = get_output("get_class")['data']
    class_context = get_output("get_class_context", session_id)['data']
    if not get_output("get_background", session_id) and get_output("get_background_context", session_id):   
        raise HTTPException(status_code=400, detail="Background and Background Context not assigned")
    background_name = get_output("get_background", session_id)['data']
    background_context = get_output("get_background_context", session_id)['data']
    if not get_output("get_ability_scores", session_id):
        raise HTTPException(status_code=400, detail="Ability scores not assigned")
    ability_scores = get_output("get_ability_scores", session_id)['data']
    if not get_output("get_proficiency_modifier", session_id):
        raise HTTPException(status_code=400, detail="Proficiency modifier not assigned")
    proficiency_modifier = get_output("get_proficiency_modifier")['data']['proficiency_modifier']
    skills = inf.get_skills(class_name, background_name, class_context, background_context, ability_scores, proficiency_modifier)
    store_output("get_skills", skills, session_id)

@app.get("/passive_perception")
async def get_passive_perception(session_id: str = Depends(get_session_id)):
    """
    Calculate and retrieve the passive perception value for a character.

    This function checks if the character's skills have been assigned. If not, it raises an HTTPException.
    It then retrieves the Perception skill value from the character's skills.
    If the passive perception value has not been previously calculated, it calculates it using the Perception skill value
    and stores the result.
    Finally, it retrieves and returns the stored passive perception value.

    Returns:
        int: The passive perception value of the character.

    Raises:
        HTTPException: If the character's skills have not been assigned.
    """
    if not get_output("get_skills", session_id):
        raise HTTPException(status_code=400, detail="Skills not assigned")
    perception = get_output("get_skills", session_id)['data']['Perception']
    passive_perception = inf.get_passive_perception(perception)
    store_output("get_passive_perception", passive_perception, session_id)

@app.get("/proficiencies_languages")
async def get_proficiencies_languages(session_id: str = Depends(get_session_id)):
    """
    Retrieves the proficiencies and languages based on the character's class and background.

    Raises:
        HTTPException: If either the class or class context is not assigned.
        HTTPException: If either the background or background context is not assigned.

    Returns:
        dict: A dictionary containing the proficiencies and languages.
    """
    if not get_output("get_class", session_id) and get_output("get_class_context", session_id):
        raise HTTPException(status_code=400, detail="Class and Class Context not assigned")
    if not get_output("get_background", session_id) and get_output("get_background_context", session_id):   
        raise HTTPException(status_code=400, detail="Background and Background Context not assigned")
    class_name = get_output("get_class", session_id)['data']
    class_context = get_output("get_class_context", session_id)['data']
    background_name = get_output("get_background", session_id)['data']
    background_context = get_output("get_background_context", session_id)['data']
    proficiencies_languages = inf.get_proficiencies_languages(class_name, background_name, class_context, background_context)
    store_output("get_proficiencies_languages", proficiencies_languages, session_id)

@app.get("/equipment_money")
async def get_equipment_money(session_id: str = Depends(get_session_id)):
    """
    Retrieves the equipment money based on the character's class and background.

    This function checks if the class and background, along with their contexts, 
    are assigned. If not, it raises an HTTPException. It then fetches the class 
    name, class context, background name, and background context. If the equipment 
    money is not already stored, it calculates the equipment money using the 
    provided information and stores it. Finally, it returns the stored equipment money.

    Raises:
        HTTPException: If class and class context are not assigned.
        HTTPException: If background and background context are not assigned.

    Returns:
        dict: The equipment money information.
    """
    if not get_output("get_class", session_id) and get_output("get_class_context", session_id):
        raise HTTPException(status_code=400, detail="Class and Class Context not assigned")
    if not get_output("get_background", session_id) and get_output("get_background_context", session_id):   
        raise HTTPException(status_code=400, detail="Background and Background Context not assigned")
    class_name = get_output("get_class", session_id)['data']
    class_context = get_output("get_class_context", session_id)['data']
    background_name = get_output("get_background", session_id)['data']
    background_context = get_output("get_background_context", session_id)['data']
    equipment_money = inf.get_equipment_money(class_name, background_name, class_context, background_context)
    store_output("get_equipment_money", equipment_money, session_id)

@app.get("/attacks")
async def get_attacks(session_id: str = Depends(get_session_id)):
    """
    Retrieves the attack details for a character based on their proficiencies, ability modifiers, and proficiency modifier.

    Raises:
        HTTPException: If any of the required data (proficiencies and languages, ability modifiers, or proficiency modifier) is not assigned.

    Returns:
        dict: A dictionary containing the attack details.
    """
    if not get_output("get_proficiencies_languages", session_id):
        raise HTTPException(status_code=400, detail="Proficiencies and Languages not assigned")
    weapons = get_output("get_proficiencies_languages", session_id)['data']['weapons']
    if not get_output("get_ability_modifier", session_id):
        raise HTTPException(status_code=400, detail="Ability mofidiers not assigned")
    ability_modifier = get_output("get_ability_modifier", session_id)['data']
    if not get_output("get_proficiency_modifier", session_id):
        raise HTTPException(status_code=400, detail="Proficiency modifier not assigned")
    proficiency_modifier = get_output("get_proficiency_modifier", session_id)['data']['proficiency_modifier']
    attacks = inf.get_attacks_damage(weapons, ability_modifier["dexterity"], ability_modifier["strength"], proficiency_modifier)
    store_output("get_attacks", attacks, session_id)

@app.get("/armor")
async def get_armor_class(session_id: str = Depends(get_session_id)):
    """
    Calculate and retrieve the armor class for a character.

    This function performs the following steps:
    1. Checks if proficiencies and languages are assigned. If not, raises an HTTPException.
    2. Retrieves the armor proficiency data.
    3. Checks if ability modifiers are assigned. If not, raises an HTTPException.
    4. Retrieves the dexterity modifier.
    5. If the armor class is not already calculated, it calculates the armor class using the armor proficiency and dexterity modifier, and stores the result.
    6. Retrieves and returns the calculated armor class.

    Raises:
        HTTPException: If proficiencies and languages are not assigned.
        HTTPException: If ability modifiers are not assigned.

    Returns:
        dict: The calculated armor class.
    """
    if not get_output("get_proficiencies_languages", session_id):
        raise HTTPException(status_code=400, detail="Proficiencies and Languages not assigned")
    armor = get_output("get_proficiencies_languages", session_id)['data']['armor']
    if not get_output("get_ability_modifier", session_id):
        raise HTTPException(status_code=400, detail="Ability mofidiers not assigned")
    dexterity_modifier = get_output("get_ability_modifier", session_id)['data']['dexterity']
    armor = inf.get_armor_class(armor, dexterity_modifier)
    store_output("get_armor_class", armor, session_id)

@app.get("/initative")
async def get_initiative(session_id: str = Depends(get_session_id)):
    """
    Calculate and retrieve the initiative value for a character based on their dexterity modifier.

    This function checks if the ability modifiers have been assigned. If not, it raises an HTTPException.
    It then retrieves the dexterity modifier and checks if the initiative value has already been stored.
    If not, it calculates the initiative based on the dexterity modifier and stores it.
    Finally, it returns the stored initiative value.

    Returns:
        dict: A dictionary containing the initiative value.

    Raises:
        HTTPException: If the ability modifiers are not assigned.
    """
    if not get_output("get_ability_modifier", session_id):
        raise HTTPException(status_code=400, detail="Ability mofidiers not assigned")
    dexterity_modifier = get_output("get_ability_modifier", session_id)['data']['dexterity']
    speed = {"initiative": dexterity_modifier} 
    store_output("get_initiative", speed, session_id)

@app.get("/speed")
async def get_speed(session_id: str = Depends(get_session_id)):
    """
    Retrieves the speed for a character based on their race and race context.

    This function first checks if the race and race context are assigned. If not, it raises an HTTPException.
    It then retrieves the race and race context, and if the speed is not already stored, it calculates the speed
    using the `inf.get_speed` function and stores it. Finally, it returns the stored speed.

    Raises:
        HTTPException: If the race and race context are not assigned.

    Returns:
        int: The speed of the character.
    """
    if not get_output("get_race", session_id) and get_output("get_race_context", session_id):
        raise HTTPException(status_code=400, detail="Race and RAce Context not assigned")
    race = get_output("get_race", session_id)
    race_context = get_output("get_race_context", session_id)
    speed = inf.get_speed(race, race_context)
    store_output("get_speed", speed, session_id)

@app.get("/hit_dice")
async def get_hit_dice(session_id: str = Depends(get_session_id)):
    """
    Retrieves the hit dice for a character based on their class and class context.

    This function first checks if the class and class context are assigned. If not, it raises an HTTPException.
    It then retrieves the class name and class context. If the hit dice information is not already stored,
    it fetches the hit dice using the `inf.get_hit_dice` function and stores it. Finally, it returns the hit dice.

    Raises:
        HTTPException: If the class and class context are not assigned.

    Returns:
        dict: The hit dice information.
    """
    if not get_output("get_class", session_id) and get_output("get_class_context", session_id):
        raise HTTPException(status_code=400, detail="Class and Class Context not assigned")
    class_name = get_output("get_class", session_id)['data']
    class_context = get_output("get_class_context", session_id)['data']
    hit_dice = inf.get_hit_dice(class_name, class_context)
    store_output("get_hit_dice", hit_dice, session_id)

@app.get("/point_maximum")
async def get_hit_point_maximum(session_id: str = Depends(get_session_id)):
    """
    Calculate and retrieve the maximum hit points for a character.

    This function checks if the hit dice and ability modifiers are assigned.
    If not, it raises an HTTPException with a 400 status code. It then calculates
    the hit point maximum using the constitution modifier and hit dice, stores the
    result, and returns the maximum hit points.

    Raises:
        HTTPException: If hit dice or ability modifiers are not assigned.

    Returns:
        dict: The maximum hit points for the character.
    """
    if not get_output("get_hit_dice", session_id):
        raise HTTPException(status_code=400, detail="Hit dice not assigned")
    if not get_output("get_ability_modifier", session_id):
        raise HTTPException(status_code=400, detail="Ability mofidiers not assigned")
    constitution_modifier = get_output("get_ability_modifier", session_id)['data']['constitution']
    hit_dice = get_output("get_hit_dice", session_id)['data']['hit_dice']
    point_maximum = inf.get_point_maximun(hit_dice, constitution_modifier)
    store_output("get_hit_point_maximum", point_maximum, session_id)

@app.get("/current_hit_point")
async def get_current_hit_point(session_id: str = Depends(get_session_id)):
    """
    Retrieves the current hit point value for a character.

    This function checks if the maximum hit point value has been assigned.
    If not, it raises an HTTPException with a status code of 400.
    If the current hit point value is not already stored, it initializes it
    with the maximum hit point value. Finally, it returns the current hit
    point value.

    Returns:
        dict: A dictionary containing the current hit point value.

    Raises:
        HTTPException: If the maimum hit point value is not assigned.
    """
    if not get_output("get_hit_point_maximum", session_id):
        raise HTTPException(status_code=400, detail="Hit point maximum not assigned")
    current_hit_point = {"current_hit_point": get_output("get_hit_point_maximum", session_id)['data']}
    store_output("get_current_hit_point", current_hit_point, session_id)

@app.get("features")
async def get_features(session_id: str = Depends(get_session_id)):
    """
    Retrieves and stores the features for a character based on class, background, and race.

    Raises:
        HTTPException: If class and class context, background and background context, 
                       or race and race context are not assigned.

    Returns:
        dict: The features of the character.
    """
    if not get_output("get_class", session_id) and get_output("get_class_context", session_id):
        raise HTTPException(status_code=400, detail="Class and Class Context not assigned")
    class_name = get_output("get_class", session_id)['data']
    class_context = get_output("get_class_context", session_id)['data']
    if not get_output("get_background", session_id) and get_output("get_background_context", session_id):   
        raise HTTPException(status_code=400, detail="Background and Background Context not assigned")
    background_name = get_output("get_background", session_id)['data']
    background_context = get_output("get_background_context", session_id)['data']
    if not get_output("get_race", session_id) and get_output("get_race_context", session_id):   
        raise HTTPException(status_code=400, detail="Race and Race Context not assigned")
    race_name = get_output("get_race", session_id)['data']
    race_context = get_output("get_race_context", session_id)['data']
    features = inf.get_features(class_name, class_context, background_name, background_context, race_name, race_context)
    store_output("get_features", features, session_id)

@app.get("traits")
async def get_traits(session_id: str = Depends(get_session_id)):
    """
    Retrieves and stores character traits based on class, background, and race.

    This function checks if the class, background, and race along with their contexts
    are assigned. If any of these are not assigned, it raises an HTTPException with
    status code 400. If all required data is available, it retrieves the traits using
    the provided information and stores the result.

    Raises:
        HTTPException: If class and class context are not assigned.
        HTTPException: If background and background context are not assigned.
        HTTPException: If race and race context are not assigned.

    Returns:
        dict: The output traits retrieved and stored.
    """
    if not get_output("get_class", session_id) and get_output("get_class_context", session_id):
        raise HTTPException(status_code=400, detail="Class and Class Context not assigned")
    class_name = get_output("get_class", session_id)['data']
    class_context = get_output("get_class_context", session_id)['data']
    if not get_output("get_background", session_id) and get_output("get_background_context", session_id):   
        raise HTTPException(status_code=400, detail="Background and Background Context not assigned")
    background_name = get_output("get_background", session_id)['data']
    background_context = get_output("get_background_context", session_id)['data']
    if not get_output("get_race", session_id) and get_output("get_race_context", session_id):   
        raise HTTPException(status_code=400, detail="Race and Race Context not assigned")
    race_name = get_output("get_race", session_id)['data']
    race_context = get_output("get_race_context", session_id)['data']
    traits = inf.get_traits(class_name, class_context, background_name, background_context, race_name, race_context)
    store_output("get_traits", traits, session_id)

@app.get("character_name")
async def get_character_name(session_id: str = Depends(get_session_id)):
    """
    Retrieves the character name based on class, background, and race information.

    This function checks if the class, background, and race information along with their contexts
    are available. If any of these are missing, it raises an HTTPException with a 400 status code.
    If the character name is not already generated, it calls the `inf.get_character_name` function
    to generate it and stores the result. Finally, it returns the generated character name.

    Raises:
        HTTPException: If class and class context, background and background context, or race and race context are not assigned.

    Returns:
        str: The generated character name.
    """
    if not get_output("get_class", session_id) and get_output("get_class_context", session_id):
        raise HTTPException(status_code=400, detail="Class and Class Context not assigned")
    class_name = get_output("get_class", session_id)['data']
    class_context = get_output("get_class_context", session_id)['data']
    if not get_output("get_background", session_id) and get_output("get_background_context", session_id):   
        raise HTTPException(status_code=400, detail="Background and Background Context not assigned")
    background_name = get_output("get_background", session_id)['data']
    background_context = get_output("get_background_context", session_id)['data']
    if not get_output("get_race", session_id) and get_output("get_race_context", session_id):   
        raise HTTPException(status_code=400, detail="Race and Race Context not assigned")
    race_name = get_output("get_race", session_id)['data']
    race_context = get_output("get_race_context", session_id)['data']
    character_name = inf.get_character_name(class_name, class_context, background_name, background_context, race_name, race_context)
    store_output("get_character_name", character_name, session_id)

@app.get("alignment")
async def get_alignment(session_id: str = Depends(get_session_id)):
    """
    Determines and returns the alignment based on traits.

    This function retrieves the traits using the `get_output` function. If traits are not assigned,
    it raises an HTTPException with status code 400. If the alignment is not already stored, it calculates
    the alignment using the `inf.get_alignment` function and stores it using the `store_output` function.
    Finally, it retrieves and returns the stored alignment.

    Raises:
        HTTPException: If traits are not assigned.

    Returns:
        dict: The alignment data retrieved from the output storage.
    """
    if not get_output("get_traits", session_id):
        raise HTTPException(status_code=400, detail="Traits not assigned")
    traits = get_output("get_traits", session_id)['data']
    alignment = inf.get_alignment(traits)
    store_output("get_alignment", alignment, session_id)

@app.get("/all")
async def get_all(request: Request):
    """
    Aggregates and executes a series of functions to gather all necessary 
    information for a Dungeons and Dragons character. This includes:
    
    - Race and race context
    - Class and class context
    - Background and background context
    - Abilities, ability scores, and ability modifiers
    - Proficiency modifiers, proficiencies, and languages
    - Attacks, armor class, initiative, and speed
    - Hit dice, hit point maximum, and current hit points
    - Features and traits
    - Character name and alignment
    
    This function calls each of these individual functions in sequence to 
    compile a complete set of character data.
    """
    session_id = get_session_id(request)
    await get_race(session_id)
    await get_race_context(session_id)
    await get_class(session_id)
    await get_background(session_id)
    await get_class_context(session_id)
    await get_background_context(session_id)
    await get_abilities(session_id)
    await get_ability_scores(session_id)
    await get_ability_modifier(session_id)
    await get_proficiency_modifier(session_id)
    await get_proficiencies_languages(session_id)
    await get_attacks(session_id)
    await get_armor_class(session_id)
    await get_initiative(session_id)
    await get_speed(session_id)
    await get_hit_dice(session_id)
    await get_hit_point_maximum(session_id)
    await get_current_hit_point(session_id)
    await get_features(session_id)
    await get_traits(session_id)
    await get_character_name(session_id)
    await get_alignment(session_id)